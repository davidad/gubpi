(****************************************************************************************)
(*                                                                                      *)
(*                                      ConstraintSolver.fs                             *)
(*                                                                                      *)
(****************************************************************************************)
(*                                                                                      *)
(* Solves the constraints generated by the type system using widening                   *)
(*                                                                                      *)
(****************************************************************************************)

module ConstraintSolver

open Interval
open Util
open PrimitiveFunctions
open PrimitiveDistributions
open Expression
open ConstraintGeneration

type private IntervalLattice =
    | Bottom
    | I of Interval

type private Assignment = Map<int, IntervalLattice>

type private JoinOperator = IntervalLattice * IntervalLattice -> IntervalLattice

/// A precise join that suffers from infinite ascending chains
let private simpleJoin: JoinOperator =
    function
    | Bottom, Bottom -> Bottom
    | Bottom, a -> a
    | a, Bottom -> a
    | I x, I y -> I (hull x y)

/// A Join operator based on simple widening where we disallow intervals to grow outwards
let private simpleWiden: JoinOperator =
    function
    | Bottom, Bottom -> Bottom
    | Bottom, a -> a
    | a, Bottom -> a
    | I x, I y ->
        let a, b = x.ToPair
        let c, d = y.ToPair
        if a <= c && d <= b then I (preciseInterval a b)
        elif c < a && d <= b then I (preciseInterval (-infinity) b)
        elif a <= c && b < d then I (preciseInterval a infinity)
        else I allReals

/// Given a set of constraints this generates an initial assignment by checking the constraints for constant constraints
/// It also eliminates those and returns the set of relevant constraints
let private initialAssignment (constraints: list<Constraint>) =
    let usedVars =
        constraints
        |> List.map (fun c -> c.UsedVars)
        |> Set.unionMany

    // Intially all vars are mapped to Bottom
    let mutable assignment =
        [ for var in usedVars do
              (var, Bottom) ]
        |> Map.ofSeq

    let mutable remainingConstraints = []

    // For each equality constraint we can simply update the initial assignment. All other constraints are relevant and added to remainingConstraints.
    for c in constraints do
        match c with
        | Equality (var, interval) -> assignment <- Map.add var (I interval) assignment
        | _ -> remainingConstraints <- c :: remainingConstraints

    remainingConstraints, assignment

// Counts how often each constraint has been fulfilled. This allows us to apply widening only if the same constraint has been fulfilled multiple times. 
let mutable constraintCounter = Map.empty


/// Solves a single constraint given an initial assignment by increasing the intervals to satisfy constraint.
/// The function returns the new assignment and the id of the interval that was enlarged
let private solveConstraint (constr: Constraint) (assignment: Assignment) =

    let numberOfResolvings =
        if Map.containsKey constr constraintCounter then
            constraintCounter.[constr]
        else
            constraintCounter <- Map.add constr 0 constraintCounter
            0

    constraintCounter <- Map.add constr (constraintCounter.[constr] + 1) constraintCounter

    let join =
        if numberOfResolvings < 2 then
            // For the first two iterations, we use the precise Join
            simpleJoin
        else
            // Afterwards we use widening to ensure termination
            simpleWiden

    // Check the constraint and enlarge the relevant interval to satisfy it
    match constr with
    | Equality (var, iv) -> (var, I iv)
    | Subset (i, j) -> (j, join (Map.find j assignment, Map.find i assignment))
    | FunctionResult (i, funSym, args) ->
        let pF = lookupFunctionSymbol funSym

        let mappedArgs = (List.map (fun x -> Map.find x assignment)) args

        if (List.exists (fun a -> a = Bottom) mappedArgs) then
            (i, Bottom)
        else
            let mappedIntervals =
                List.map
                    (fun iv ->
                        match iv with
                        | I a -> a
                        | Bottom -> failwith "Error")
                    mappedArgs
                |> List.toArray

            let functionEval =
                pF.ComputeInterval mappedIntervals

            (i, join (Map.find i assignment, I functionEval))
    | DistributionResult (i, distSym, args) ->
        let pD = lookupDistributionSymbol distSym

        let mappedArgs = (List.map (fun x -> Map.find x assignment)) args

        if (List.exists (fun a -> a = Bottom) mappedArgs) then
            (i, Bottom)
        else
            let mappedIntervals =
                List.map
                    (fun iv ->
                        match iv with
                        | I a -> a
                        | Bottom -> failwith "Impossible")
                    mappedArgs

            let functionEval =
                pD.BoundsOnSamples mappedIntervals

            (i, join (Map.find i assignment, I functionEval))

/// Solve a list of constraints and returns the least solution
let private solve (initialConstraints: list<Constraint>) : Assignment =
    
    // Generate the initial assignment and remove redundant constraints (which were used to construct the initial assignment).
    let mutable constraints, assignment = initialAssignment initialConstraints

    let usedVars = constraints |> (List.map (fun c -> c.UsedVars))

    let maxVar =
        usedVars |> Set.unionMany |> Set.maxElement

    // A map that maps all variables to the set of variables that affect it
    // This allows for a more efficient order in which we resolve the constraints
    let varDepMap = Array.create (maxVar + 1) Set.empty

    for constr in constraints do
        let targetVar = constr.TargetVar
        let sourceVars = constr.SourceVars

        for var in sourceVars do
            Array.set varDepMap var (Set.add targetVar varDepMap.[var])


    // Compute the SCC components and solve them in increasing order
    let components = SCC.computeSCC maxVar varDepMap

    for comp in components do
        // Filter out those constraints that affect the variables in comp
        let relevantConstraints =
            List.filter (fun (c: Constraint) -> Set.contains (c.TargetVar) comp) constraints

        // Add each variable to those that use it values and lie within the current SCC
        let mutable affectedConstraintMap: Map<int, Set<Constraint>> =
            [ for var in comp do
                  (var,
                   List.filter (fun (c: Constraint) -> Set.contains var (c.SourceVars)) relevantConstraints
                   |> set) ]
            |> Map.ofSeq

        // Init the worklist with all constraints in this SCC
        let mutable worklist = set relevantConstraints

        while worklist.Count <> 0 do
            let constr = worklist |> Set.toSeq |> Seq.head
            worklist <- Set.remove constr worklist

            let (var, assignedInterval) = solveConstraint constr assignment

            if (Map.find var assignment <> assignedInterval) then
                // the value was updated. Add all
                assignment <- Map.add var assignedInterval assignment

                for constr' in affectedConstraintMap.[var] do
                    if constr <> constr' then
                        worklist <- Set.add constr' worklist

    assignment

/// Given an expression, compute all locations where a fixpoint is located
let rec private computeAllFixpointLocations (M : Expr) =
    match M with
        | Numeral _ | IntervalNumeral _ | Variable _ | SampleVariable _ | EmptyList _ -> []
        | Application (M1, M2) ->
            (computeAllFixpointLocations M1
            |> List.map LocApplicationFunction)
            @
            (computeAllFixpointLocations M2
            |> List.map LocApplicationArgument)
        | Abstraction (_, _, M) ->
            computeAllFixpointLocations M
            |> List.map LocAbstraction
        | Fixpoint _ ->
            // NOTE: We only get the location of top-level fixpoints. In particular, fixpoint positions are not overlapping
            [LocEpsilon]
        | Sample (_, args) ->
            args
            |> List.map computeAllFixpointLocations
            |> List.mapi (fun i -> List.map (fun y -> LocSample(i, y)))
            |> List.concat
        | Conditional (M1, M2, M3) ->
            List.concat [
                    (computeAllFixpointLocations M1
                    |> List.map LocConditionalGuard);
                    (computeAllFixpointLocations M2
                    |> List.map LocConditionalThen);
                    (computeAllFixpointLocations M3
                    |> List.map LocConditionalElse)
                ]
        | Score M ->
            computeAllFixpointLocations M
            |> List.map LocScore
        | PrimF (_, args) ->
            args
            |> List.map computeAllFixpointLocations
            |> List.mapi (fun i -> List.map (fun y -> LocPrimF(i, y)))
            |> List.concat
        | SymPrimF (_, args) ->
            args
            |> List.map computeAllFixpointLocations
            |> List.mapi (fun i -> List.map (fun y -> LocSymPrimF(i, y)))
            |> List.concat
        | ConsList(M, N) ->
            List.concat [
                    (computeAllFixpointLocations M
                    |> List.map LocConsLeft);
                    (computeAllFixpointLocations N
                    |> List.map LocConsRight)
                ]
        | FoldList(M, N, _, _, P) ->
            List.concat [
                    (computeAllFixpointLocations M
                    |> List.map LocFoldListMatch);
                    (computeAllFixpointLocations N
                    |> List.map LocFoldListEmpty)
                    (computeAllFixpointLocations P
                    |> List.map LocFoldListCons)
                ]
        | Tuple args ->
            args
            |> List.map computeAllFixpointLocations
            |> List.mapi (fun i -> List.map (fun y -> LocTuple(i, y)))
            |> List.concat
        | TupleMatch (_, M, N) ->
            List.concat [
                    (computeAllFixpointLocations M
                    |> List.map LocTupleMatchArg);
                    (computeAllFixpointLocations N
                    |> List.map LocTupleMatchBody)
                ]

/// This function removes all fixpoints from a term M by using the type system and static analysis 
let removeAllFixpointsViaSA (M: Expr) (bounds: VarBoundMap) =
    // A generator for fresh numbers
    let gen =
        let state = ref 0
        fun () ->
            let x = !state
            state := x + 1
            x
    // Generate the typing constraints using the type system
    let (locType, constraints) = generateConstraint M bounds gen
    
    // Solve the constraints
    let assignment = solve constraints

    let mutable term = M
    
    // We now iterate over all fixpoints in term M
    // For each fixpoint subexpression we use the type inferred at that location to remove the fixpoint
    let allFixpoints = computeAllFixpointLocations M
    for fixLoc in allFixpoints do
        let (symTy, _) = locType.[fixLoc]
        let assignmentToIvTerm i =
            match assignment.[i] with
                | I x -> IntervalNumeral x
                | Bottom -> failwith "impossible bounds in fixed point approximation"
        let rec symTyToTerm =
            function
            | SymReal v -> assignmentToIvTerm v
            | SymTupleTy tl -> Tuple (List.map symTyToTerm tl)
            | SymListTy ty -> symTyToTerm ty // should be new constructor, e.g. Repetitions (symToConcreteTy ty)
            | SymArrow (_, (retTy, weight)) -> Abstraction("", None, Application(Abstraction("", None, symTyToTerm retTy), Score (assignmentToIvTerm weight)))
            
            
        // Compute a replacement term for the subexpression and replace the term at location fixLoc with replacement
        let replacement = symTyToTerm symTy
        term <- term.ReplaceSubExpr fixLoc replacement

    term